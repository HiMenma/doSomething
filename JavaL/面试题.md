

#### java1.8新特性（百度百度）

##### 1.函数式接口

- 函数式接口的提出是为了给Lambda表达式的使用提供更好的支持。

##### 2.lumbda表达式

|                    前置                    |                         语法                         |
| :----------------------------------------: | :--------------------------------------------------: |
|               无参数无返回值               |       () -> System.out.println(“Hello WOrld”)        |
|             有一个参数无返回值             |             (x) -> System.out.println(x)             |
|          有且只有一个参数无返回值          |              x -> System.out.println(x)              |
|  有多个参数，有返回值，有多条lambda体语句  | (x，y) -> {System.out.println(“xxx”);return xxxx;}； |
| 有多个参数，有返回值，只有一条lambda体语句 |                    (x，y) -> xxxx                    |

##### 3.使用匿名内部类

- 使用匿名内部类，就不需要每次都新建一个实现类，直接在方法内部实现。看到匿名内部类，不禁想起了Lambda表达式。

##### 4.新的日期API LocalDate | LocalTime | LocalDateTime

#### 集合：

**1**.集合有哪些

- Collection、List、ArrayList、LinkedList、Vector、Set、HashSet、TreeSet、Map、HashMap、TreeMap

**2**.数组底层

- java中把内存分为了堆内存和栈内存，当初始化数组时，堆内存分配相应大小的连续的内存块，并将第一个内存块的地址放入栈内存中存储。这样读取数据的时候取第0个就是首地址的内存中的数据，第1个就是首地址+1的内存块中数据。其余删除与写入操作与读取类似。

**3**.ArrayList与LinkList区别

- ArrayList是数组，LinkedList是双向链表，查询速度ArrayList快，但是LinkedList增删更快。

  

**4**.HashMap的实现原理

- 1，hashmap是我们几乎每天用到的集合类,它以键值对的形式存在。
  2,在jdk1.7中：底层是数组加链表，1.8中采用的是 数组加链表加红黑树 ，红黑树的引入是为了提高查询效率
  3，1.7中hash碰撞采用 头插法 ，头插法好像记得会形成循环链表，1.8是  尾插法
  4，hash算法1.8进行了简化，记不清了，
  5，最好传入一个二的次幂的初始化容量， put时，会初始化数组，容量为大于等于初始化容量的最近的二次幂，比如初始化容量为6，他初始化就是8。
  6，key的hash值 与 上容量-1，计算出所在位置
  7，扩容的问题：加载因子0.75，达到 容量 *0.75后就会扩容，两倍扩容  
  8，树化，数组容量达到64,链表长度大于等于8，后才会进行树化，链表长度小于6就会解除树化

  

[**5**.Map的遍历方式有那些](https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw)：

- keyset或entrySet加上增强for进行遍历

- 通过Iterator 迭代器加上keyset和entrySet遍历

- 在for循环中遍历key或者values，若只需要map中的key或者value时使用，在性能上比使用entrySet较好

- Lambda表达式

  ```java
  //Lambda
  map.forEach((key, value) -> {
    System.out.println(key);
    System.out.println(value);
  });
  ```

- 6.Streams API 单和多线程遍历

**6.**Map中key是否可以重复，value是否可以重复

- key不可以重复，value可以。

[**7**.List中元素可以重复如何去重](https://www.cnblogs.com/niwotaxuexiba/p/9681104.html)

- 嵌套循环遍历判断元素是否有相同的，即remove;
-  通过HashSet踢除重复元素
- 把list里的对象遍历一遍，用list.contains()，如果不存在就放入到另外一个list集合中

#### 异常：

#### ![](https://img2020.cnblogs.com/blog/1141396/202007/1141396-20200717193336761-129503931.png)

1.异常的分类

- Java异常分为Error（程序无法处理的错误），和Exception（程序本身可以处理的异常）。这两个类均 继承Throwable。
-  Error常见的有StackOverFlowError,OutOfMemoryError等等。 
- Exception可分为运行时异常和非运行时异常。对于运行时异常，可以利用try catch的方式进行处理，也 可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。

2.平时遇到的异常及场景

| 异常类型                      | 说明                                                    |
| ----------------------------- | ------------------------------------------------------- |
| Exception                     | 异常层次结构的根类                                      |
| RuntimeException              | 运行时异常，多数 java.lang 异常的根类                   |
| ArithmeticException           | 算术异常，**如以零做除数**                              |
| ArraylndexOutOfBoundException | **数组下标越界异常**,当使用数组超出定义数组下标时会抛出 |
| NullPointerException          | 尝试访问 对象成员是null 时，会报**空指针异常**          |
| ClassNotFoundException        | **缺少类的异常**，如当未找到MySQL驱动程序时抛出         |
| NumberF ormatException        | 数字转化格式异常，比如字符串到 float 型数字的转换无效   |
| IOException                   | I/O 异常的根类                                          |
| FileNotFoundException         | **找不到文件**                                          |
| EOFException                  | 文件结束                                                |
| InterruptedException          | 线程中断                                                |
| IllegalArgumentException      | 方法接收到非法参数                                      |
| ClassCastException            | 类型转换异常                                            |
| SQLException                  | **操作数据库异常**                                      |
| Virtual MachineError          | java 虚拟机运行错误                                     |
| OutOfMemoryError              | 虚拟机内存不够错误                                      |
| NoClassDefFoundError          | 类定义错误                                              |

[3.如何自定义异常及使用](https://blog.csdn.net/liangruilz/article/details/89881497)

- 先extends（继承）某Exception，例如RuntimeException，再定义有参和无参的构造方法；
- 再根据需要，再throw异常，加上自己的提示。

#### [常用类：](https://blog.csdn.net/sugar_no1/article/details/88016599)

1.StringBuffer和StringBuillder的区别

- String类采用利用final修饰的字符数组进行字符串保存，因此不可变。如果对String类型对象修改，需要新建对象，将老字符和新增加的字符一并存进去。
- StringBuilder，采用无final修饰的字符数组进行保存，因此可变。但线程不安全。
- StringBuffer，采用无final修饰的字符数组进行保存，可理解为实现线程安全的StringBuilder。

2.Object、String、StringBuilder、Scanner、Math、Random、Date、DateFormat、SimpleDateFormat、Calendar、System、BigInteger

#### IO流：

IO流的分类

一个java对象怎么保存到其他文件中

序列化和反序列化



#### 多线程：

###### 1.线程的状态

- 线程生命周期：new 、runnable、terminated
- 新生、就绪、运行、阻塞、死亡

###### 2.sleep和wait区别

- 两者最主要的区别在于：**`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- 两者都可以暂停线程的执行。
- `wait()` 通常被用于线程间交互/通信，`sleep() `通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify() `或者 `notifyAll()` 方法。`sleep() `方法执行完成后，线程会自动苏醒。或者可以使用 `wait(long timeout)` 超时后线程会自动苏醒。

###### 3.线程和进程

- **进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

  在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。

- **线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

###### 4.创建线程

- 1.继承Thread类，重写run方法，创建子类对象，在调用start。
- 2.实现Runnable接口，重写run方法，创建Thread对象再将子类对象丢进去，再调用start。
- 3.实现Callable<>接口并throws异常

###### 5.如何创建线程池以及线程池的种类

​	5.1为啥要用线程池

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

- **提高响应速度**。当任务到达时，任务可以不需要的等到线程创建就能立即执行。

- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

  5.2创建线程池和种类

  **方式一：通过构造方法实现**

![ThreadPoolExecutor构造方法](https://camo.githubusercontent.com/f724bf3906393acbfa27ef0bbf75d0f80e408aca352417e130851b52951c45d2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f546872656164506f6f6c4578656375746f722545362539452538342545392538302541302545362539362542392545362542332539352e706e67)

​	**方式二：通过 Executor 框架的工具类 Executors 来实现**

我们可以创建三种类型的 ThreadPoolExecutor：

- **FixedThreadPool** ： 该方法返回一个**固定线程数量**的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
- **SingleThreadExecutor：** 方法返回一个**只有一个线程**的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
- **CachedThreadPool：** 该方法返回一个**可根据实际情况调整线程数量的**线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。

对应 **Executors 工具类**中的方法如图所示：

![Executor框架的工具类](https://camo.githubusercontent.com/764b0fb2d22df745240850ae2d874e3bbb798494d5d32d6e3ca7eee44186c3b8/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4578656375746f722545362541312538362545362539452542362545372539412538342545352542372541352545352538352542372545372542312542422e706e67)



- **newScheduleThreadPool：**创建一个**定长**的线程池，而且支持**定时的以及周期性的任务执行**。
- **newSingleThreadScheduledExecutor：**创建一个**单线程**执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行并且可**定时**或者延迟执行线程活动。

### Spring

#### 1.注解如@service @Autowired及实现原理

- ####  `@Autowired`

自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。

```
@Service
public class UserService {
  ......
}

@RestController
@RequestMapping("/users")
public class UserController {
   @Autowired
   private UserService userService;
   ......
}
```

- `@Component` ：通用的注解，可标注任意类为 `Spring` 组件。如果一个 Bean 不知道属于哪个层，可以使用`@Component` 注解标注。
- `@Repository` : 对应**持久层**即 Dao 层，主要用于数据库相关操作。
- `@Service` : 对应**服务层**，主要涉及一些复杂的逻辑，需要用到 Dao 层。
- `@Controller` : 对应 Spring MVC **控制层**，主要用于接受用户请求并调用 Service 层返回数据给前端页面。
- `@RestController`注解是`@Controller和`@`ResponseBody`的合集,表示这是个控制器 bean,并且是将函数的返回值直 接填入 HTTP 响应体中,是 REST 风格的控制器。单独使用 `@Controller` 不加 `@ResponseBody`的话一般使用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。`@Controller` +`@ResponseBody` 返回 JSON 或 XML 形式数据
- `@Configuration`一般用来声明配置类，可以使用 `@Component`注解替代，不过使用`@Configuration`注解声明配置类更加语义化。



#### 2.Spring IOC & AOP

##### 2.1谈谈自己对于 Spring IoC 的了解

- IoC IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制 权，交由Spring框架来管理（相当于交给第三方）。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC 容器是 Spring ⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各 种对象。 将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤ 程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀ 样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如 何被创建出来的。 在实际项⽬中⼀个 Service 类可能有⼏百甚⾄上千个类作为它的底层，假如我 们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可 能会把⼈逼疯。如果利⽤ IoC 的话，你只需要配置好，然后在需要的地⽅引⽤就⾏了，这⼤⼤增 加了项⽬的可维护性且降低了开发难度。Spring 时代我们⼀般通过 XML ⽂件来配置 Bean，后来开发⼈员觉得 XML ⽂件来配置不太好， 于是 SpringBoot 注解配置就慢慢开始流⾏起来。

[![img](https://camo.githubusercontent.com/dd18c750a56f6d68652a5cb0e050e354ff20cbab0e8328f491a46e0b59323931/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6a6176612d67756964652d626c6f672f6672632d33363566616365623536393766303466333133393939333763303539633136322e706e67)](https://camo.githubusercontent.com/dd18c750a56f6d68652a5cb0e050e354ff20cbab0e8328f491a46e0b59323931/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6a6176612d67756964652d626c6f672f6672632d33363566616365623536393766303466333133393939333763303539633136322e706e67)



##### 2.2谈谈自己对于 AOP 的了解

AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 **JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 **Cglib** 生成一个被代理对象的子类来作为代理，如下图所示：

[![SpringAOPProcess](https://camo.githubusercontent.com/3c56fc05c00d6ecba86e493389f597c8cc2478aa1ede2867bedbb57d74d65b41/68747470733a2f2f696d616765732e7869616f7a6875616e6c616e2e636f6d2f70686f746f2f323031392f39323664666335343962303664323830613337333937663966643439626639642e6a7067)](https://camo.githubusercontent.com/3c56fc05c00d6ecba86e493389f597c8cc2478aa1ede2867bedbb57d74d65b41/68747470733a2f2f696d616765732e7869616f7a6875616e6c616e2e636f6d2f70686f746f2f323031392f39323664666335343962303664323830613337333937663966643439626639642e6a7067)

当然你也可以使用 **AspectJ** ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。

#### SpringMVC

##### 1.注解如 @request

- @PostMapping("/sign-up")  //写在方法上
- @RequestMapping("/api") //写在类上
- @GetMapping("/person/{id}")//写在方法上

##### 2.mvc的执行过程

**流程说明（重要）：**

1. 客户端（浏览器）发送请求，直接请求到 `DispatcherServlet`。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。
3. 解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理，去执行对应的Controller。
4. `HandlerAdapter` 会根据 `Handler`来调用真正的处理器开处理请求，并处理相应的业务逻辑。
5. 处理器处理完业务后，会返回一个 `ModelAndView`（数据和视图） 对象，`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
6. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
7. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。
8. 把 `View` 返回给请求者（浏览器）

![img](https://camo.githubusercontent.com/0fd35900c32b252a18ff38855ae52192f90f8884f1622bb5f92578fe68c6cb2f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f64653664326232313366313132323937323938663365323233626630386632382e706e67)



##### 3.filter过滤器

#### SpringBoot

起步依赖







#### Mybatis

mybatis比jdbc的优势以及jdbc比mybatis的优势

#### 1、#{}和${}的区别是什么？

注：这道题是面试官面试我同事的。

答：

- `${}`是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为`com.mysql.jdbc.Driver`。
- `#{}`是 sql 的参数占位符，MyBatis 会将 sql 中的`#{}`替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，`#{item.name}` 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 `param.getItem().getName()`。



#### Mysql：

sql优化

锁如表级锁行级锁

索引

视图

分页

创建用户并授予权限

更改表中列名和字段属性

delete、drop、truncate三个之间的区别

#### 单例模式、工厂模式、代理模式这几种设计模式了解一下

#### JDBC

```java
/*
 * 链接方式1
 */
public static void ConnectonTest1() throws SQLException{
	//获取Driver实现类对象
	Driver driver = new com.mysql.jdbc.Driver();
	//jdbc:mysql:协议
	//loclahost:ip地址
	//3306：端口号
	//test:数据库名
	String url = "jdbc:mysql://localhost:3306/test";
	//将用户名和密码封装在properties中
	Properties info = new Properties();
	info.setProperty("user", "root");
	info.setProperty("password", "123456");
	//获取连接
	Connection connection = driver.connect(url, info);
	System.out.println(connection);
	
}

/*没有出现如方式1中第三方的api，使程序具有更好的可移植性
 * 方式2
 */

public static void connectionTest2() throws Exception{
	//获取Driver实现类对象，使用反射
	Class forName = Class.forName("com.mysql.jdbc.Driver");
	Driver driver = (Driver)forName.newInstance();
	//提供连接的数据库
	String url = "jdbc:mysql://localhost:3306/test";
	//提供连接的用户名和密码
	Properties info = new Properties();
	info.setProperty("user", "root");
	info.setProperty("password", "123456");
	//获取连接
	Connection connect = driver.connect(url, info);
	System.out.println(connect);
}

/*
 * 方式3
 */
public static void connectionTest3() throws Exception{
	//获取driver实现类对象
	Class forName = Class.forName("com.mysql.jdbc.Driver");
	Driver driver = (Driver)forName.newInstance();
	//获取url
	String url = "jdbc:mysql://localhost:3306/test";
	//获取用户名
	String user = "root";
	//获取密码
	String password = "123456";
	//注册驱动
	DriverManager.registerDriver(driver);
	//获取连接
	Connection connection = DriverManager.getConnection(url, user, password);
	System.out.println(connection);
}

/*
 * 方式4不注册驱动
 */
public static void connectionTest4() throws Exception{
	
	//获取url
	String url = "jdbc:mysql://localhost:3306/test";
	//获取用户名
	String user = "root";
	//获取密码
	String password = "123456";
	
	//获取driver实现类对象
	Class forName = Class.forName("com.mysql.jdbc.Driver");
	//Driver driver = (Driver)forName.newInstance();
	//注册驱动
	//DriverManager.registerDriver(driver);
	//获取连接
	Connection connection = DriverManager.getConnection(url, user, password);
	System.out.println(connection);
}
```

最终版：使用配置文件

jdbc.properties

```java
user=root
password=123456
url=jdbc:mysql://localhost:3306/test
driver=com.mysql.jdbc.Driver
/*
 * 最终版：方式5
 */
public static void connectionTest5() throws Exception{
	InputStream is = ConnectionDemo.class.getClassLoader().getResourceAsStream("jdbc.properties");
	Properties  properties  = new Properties();
	properties.load(is);
	String user = properties.getProperty("user");
	String password = properties.getProperty("password");
	String url = properties.getProperty("url");
	String driver = properties.getProperty("driver");
	
	Connection connection = DriverManager.getConnection(url, user, password);
	System.out.println(connection);
```

#### 